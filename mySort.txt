Heap Sort was the group choice.

Heap Sort is a comparison-based sorting algorithm that leverages the properties of a binary heap.
The main idea is to first build a max heap (or a min heap) from the input data,
then repeatedly extract the maximum (or minimum) element from the heap and reconstruct the heap until it's empty.

function heapSort(array A):
    buildMaxHeap(A)
    for i from A.length down to 2:
        swap A[1] with A[i]
        A.heapSize = A.heapSize - 1
        maxHeapify(A, 1)

function buildMaxHeap(array A):
    A.heapSize = A.length
    for i from A.length/2 down to 1:
        maxHeapify(A, i)

function maxHeapify(array A, int i):
    left = 2 * i
    right = 2 * i + 1
    if left <= A.heapSize and A[left] > A[i]:
        largest = left
    else:
        largest = i
    if right <= A.heapSize and A[right] > A[largest]:
        largest = right
    if largest != i:
        swap A[i] with A[largest]
        maxHeapify(A, largest)

Number of Operations:

buildMaxHeap: This function is called once and runs in O(n) time.
maxHeapify: This function is called in the worst case O(n log n) times (because of the loop in heapSort). Each call to maxHeapify can be O(log n) in the worst case.
heapSort: This function involves swaps and decreasing the heap size, both of which are O(1) operations, but it calls maxHeapify n-1 times.
Complexity Analysis:

Time Complexity:

Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n log n)
Space Complexity: O(1) (in-place sort)

Explanation:

The buildMaxHeap function runs in linear time, O(n). Although maxHeapify takes O(log n) time, it's called for n/2 elements by buildMaxHeap, thus the total time for buildMaxHeap becomes O(n).

The heapSort function calls maxHeapify n-1 times which can be O(log n) in the worst case, leading to a total time of O(n log n) for the heapSort function.

Thus, combining both the above, the total time complexity for the heap sort becomes O(n + n log n) = O(n log n).

